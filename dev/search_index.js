var documenterSearchIndex = {"docs":
[{"location":"manual/implementations/","page":"Included implementations","title":"Included implementations","text":"CurrentModule = Justitia","category":"page"},{"location":"manual/implementations/#implementations","page":"Included implementations","title":"Handy implementations that come built-in","text":"","category":"section"},{"location":"manual/implementations/#Instances","page":"Included implementations","title":"Instances","text":"","category":"section"},{"location":"manual/implementations/","page":"Included implementations","title":"Included implementations","text":"AbstractMOIBackedInstance\nSimpleMOIBackedInstance\nMIPLIBInstance","category":"page"},{"location":"manual/implementations/#Justitia.AbstractMOIBackedInstance","page":"Included implementations","title":"Justitia.AbstractMOIBackedInstance","text":"Instance that is internally stored as an MathOptInterface model.\n\nabstract type AbstractMOIBackedInstance <: AbstractInstance end\n\nTo interact with the underlying MathOptInterface model, use:\n\nget_moi_model(model::AbstractMOIBackedInstance)::MOI.ModelLike\n\n\n\n\n\n","category":"type"},{"location":"manual/implementations/#Justitia.SimpleMOIBackedInstance","page":"Included implementations","title":"Justitia.SimpleMOIBackedInstance","text":"A \"simple\" AbstractMOIBackedInstance where the underlying MathOptInterface model is stored in a field.\n\nstruct SimpleMOIBackedInstance{T <: MOI.ModelLike} <: AbstractInstance\n    model::T\nend\n\n\n\n\n\n","category":"type"},{"location":"manual/implementations/#Justitia.MIPLIBInstance","page":"Included implementations","title":"Justitia.MIPLIBInstance","text":"A MIPLIB 2017 instance stored in a MathOptInterface backing model.\n\nMIPLIBInstance(instance_name::String)\n\nPulls down the MIPLIB instance named instance_name from the official MIPLIB website using curl.\n\nSome pieces of the functional interface are implemented:\n\nprep_instance!(instance::MIPLIBInstance)\n\nnote: Note\nYou must call prep_instance! on a MIPLIBInstance to populate the internal MathOptInterface model backing it.\n\n\n\n\n\n","category":"type"},{"location":"manual/implementations/#Approaches","page":"Included implementations","title":"Approaches","text":"","category":"section"},{"location":"manual/implementations/","page":"Included implementations","title":"Included implementations","text":"MOIBasedApproach","category":"page"},{"location":"manual/implementations/#Justitia.MOIBasedApproach","page":"Included implementations","title":"Justitia.MOIBasedApproach","text":"An approach that, given an instance, will merely convert that instance into a MathOptInterface.ModelLike. For instance, this could encapsulate a AbstractOptimizer, which ingests an instance and passes that instance to the underlying solver through the MathOptInterface API.\n\nMOIBasedApproach{T}() where {T <: MOI.AbstractOptimizer}\nMOIBasedApproach{T}(factory::Function) where {T <: MOI.AbstractOptimizer}\n\nThe underlying MathOptInterface will either be inferred from T, or you can optionally pass a factory function to the constructor. This factory must respect the signature\n\n(instance::AbstractInstance, config::Dict{String,Any}) --> MathOptInterface.AbstractOptimizer.\n\nSome pieces of the functional interface are implemented:\n\nfunction build_model(\n    approach::MOIBasedApproach{T},\n    inst::AbstractMOIBackedInstance,\n    config::Dict{String,Any} = Dict{String,Any}(),\n) where {T <: MathOptInterface.AbstractOptimizer}\n\n\n\n\n\n","category":"type"},{"location":"manual/implementations/#Models","page":"Included implementations","title":"Models","text":"","category":"section"},{"location":"manual/implementations/","page":"Included implementations","title":"Included implementations","text":"MOIModel","category":"page"},{"location":"manual/implementations/#Justitia.MOIModel","page":"Included implementations","title":"Justitia.MOIModel","text":"A \"simple\" model that merely wraps around an underlying MathOptInterface model.\n\nstruct MOIModel{T <: MOI.AbstractOptimizer} <: AbstractModel\n    opt::T\nend\n\nSome pieces of the functional interface are implemented:\n\noptimize!(model::MOIModel)\ntear_down(model::MOIModel, ::Type{MILPResult})\n\n\n\n\n\n","category":"type"},{"location":"manual/implementations/#Results","page":"Included implementations","title":"Results","text":"","category":"section"},{"location":"manual/implementations/","page":"Included implementations","title":"Included implementations","text":"MILPResult","category":"page"},{"location":"manual/implementations/#Justitia.MILPResult","page":"Included implementations","title":"Justitia.MILPResult","text":"Records solution information from a mixed-integer linear programming (MILP) problem.\n\nMILP(;\n    termination_status::MOI.TerminationStatusCode,\n    primal_status::MOI.ResultStatusCode,\n    solve_time_sec::Float64;\n    x::Union{Nothing,Vector{Float64}} = nothing,\n    primal_bound::Float64 = NaN,\n    dual_bound::Float64 = NaN,\n    node_count::Int = -1,\n    simplex_iters::Int = -1\n)\n\nRecords why the solver terminated (termination_status), if it had a feasible primal solution (primal_status), what that solution was if available (x), what the best primal cost was (primal_bound), the best available dual bound (dual_bound), elapsed solve time in seconds (solve_time_sec), and optionally the number of enumerated nodes (node_count) and total simplex iterations (simplex_iters).\n\nSome pieces of the functional interface are implemented:\n\nrecord_result(table::CSVRecord, result::MILPResult)\n\nAdditionally, there is a helper function for creating a CSVRecord with the correct headers:\n\nCSVRecord(filename::String, ::Type{MILPResult})\n\n\n\n\n\n","category":"type"},{"location":"manual/implementations/#Result-Tables","page":"Included implementations","title":"Result Tables","text":"","category":"section"},{"location":"manual/implementations/","page":"Included implementations","title":"Included implementations","text":"CSVRecord","category":"page"},{"location":"manual/implementations/#Justitia.CSVRecord","page":"Included implementations","title":"Justitia.CSVRecord","text":"A simple AbstractResultTable that uses a .csv file as a backend.\n\nCSVRecord(filename::String, headers::Union{Nothing,Vector{String}}=nothing)\n\nCreates a CSVRecord table which writes the results to a .csv file at the location filename in the file system. Optionally, pass headers specifying the names of the fields to be recorded and the first line of the created .csv will include this header information.\n\n\n\n\n\n","category":"type"},{"location":"manual/example/","page":"An example","title":"An example","text":"CurrentModule = Justitia","category":"page"},{"location":"manual/example/#An-example:-Comparing-two-MILP-solvers-on-MIPLIB-instances","page":"An example","title":"An example: Comparing two MILP solvers on MIPLIB instances","text":"","category":"section"},{"location":"manual/example/","page":"An example","title":"An example","text":"We offer a simple example showcasing how you can use Justitia. We will compare two MILP solvers (CPLEX and Gurobi) on a small selection of \"easy\" MIPLIB 2017 instances. You can do this with only a dozen lines of code:","category":"page"},{"location":"manual/example/","page":"An example","title":"An example","text":"using CPLEX, Gurobi, Justitia\n\ninstances = Dict(\n    \"10teams\" => Justitia.MIPLIBInstance(\"10teams\"),\n    \"22433\" => Justitia.MIPLIBInstance(\"22433\"),\n)\napproaches = Dict(\n    \"Gurobi\" => Justitia.MOIBasedApproach{Gurobi.Optimizer}(),\n    \"CPLEX\" => Justitia.MOIBasedApproach{CPLEX.Optimizer}(),\n)\n\nresult_table = Justitia.CSVRecord(\"results.csv\", Justitia.MILPResult)\n\nJustitia.run_experiments!(result_table, instances, approaches, Justitia.MILPResult)","category":"page"},{"location":"manual/example/","page":"An example","title":"An example","text":"If all the packages are installed correctly, running this code will leave you with a file results.csv with contents that look something like:","category":"page"},{"location":"manual/example/","page":"An example","title":"An example","text":"instance,approach,termination_status,primal_status,primal_bound,dual_bound,solve_time_sec,node_count,simplex_iters\n10teams,Gurobi,OPTIMAL,FEASIBLE_POINT,924.0,924.0,0.6151671409606934,1,9157\n10teams,CPLEX,OPTIMAL,FEASIBLE_POINT,924.0,924.0,2.1778600215911865,273,0\n22433,Gurobi,OPTIMAL,FEASIBLE_POINT,21477.0,21476.0,0.10126018524169922,1,446\n22433,CPLEX,OPTIMAL,FEASIBLE_POINT,21477.0,21477.0,0.09111189842224121,0,0","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Justitia","category":"page"},{"location":"#Justitia","page":"Home","title":"Justitia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Justitia is a simple, flexible framework for benchmarking optimization algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The basic building blocks in Justicia are Approachs (an algorithm configured in a particular way) and Instances (a concrete realization of an optimization problem). A Model couples together a single Approach with a single Instance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Models are treated as black boxes: you can build them, optimize them, and query the results, but otherwise do not interact with them. Given a Result from a solved model, you can pack them into a ResultTable for later analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main entrypoint of Justitia asks you to specify a vector of M Approachs and N Instances. It builds the M times N Models coupling each pair, optimizes each, and records the results of each in a centralized table for later analysis. Easy, right?","category":"page"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"CurrentModule = Justitia","category":"page"},{"location":"manual/interface/#interface","page":"Interface","title":"The Justitia interface: 5 types and 5 functions","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Justitia asks that you implement 5 types and 5 interface functions to run your experiments. Some useful starting points are included in the library, and are documented in the Implementations section.","category":"page"},{"location":"manual/interface/#Abstract-types","page":"Interface","title":"Abstract types","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"AbstractInstance\nAbstractApproach\nAbstractModel\nAbstractResult\nAbstractResultTable","category":"page"},{"location":"manual/interface/#Justitia.AbstractInstance","page":"Interface","title":"Justitia.AbstractInstance","text":"Subtypes contain all the information for an individual instance of an optimization problem. They either contain all of the requisite data themselves, or a mechanism to somehow retreive it from, e.g., a website.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Justitia.AbstractApproach","page":"Interface","title":"Justitia.AbstractApproach","text":"Subtypes are different approaches for solving an optimization problem. We use \"approach\" to mean a configured algorithm: that is, the algorithm (e.g. simplex), along with fixed values for all the algorithm hyperparemeters.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Justitia.AbstractModel","page":"Interface","title":"Justitia.AbstractModel","text":"Subtypes encapsulate an single approach applied to a single instance. Callers can ask to optimize a model and then query the results, but the workings of the approach are otherwise treated as a black box.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Justitia.AbstractResult","page":"Interface","title":"Justitia.AbstractResult","text":"Subtypes contain all the useful information needed for understanding how a particular approach performed on a particular instance. Typical fields stored may include solve time, or node count for a MIP-based approach.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Justitia.AbstractResultTable","page":"Interface","title":"Justitia.AbstractResultTable","text":"Subtypes store the results for experiments across multiple approaches and multiple instances. Backends could be as simple as a CSV file, or something more complex like HDF5.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#functional_interface","page":"Interface","title":"Functional interface","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"prep_instance!\nbuild_model\noptimize!\ntear_down\nrecord_result!","category":"page"},{"location":"manual/interface/#Justitia.prep_instance!","page":"Interface","title":"Justitia.prep_instance!","text":"prep_instance!(instance::AbstractInstance)::Nothing\n\nPrepare an instance for experimentation. This is useful if there is a lightweight way to represent an instance (e.g. a string name in an instance library), but collecting the data is relatively costly (e.g. download something from the web and converting it to the right file format). Additionally, this prep work can do more complex pre-processing: if you are evaluating methods for dual bounds, this function could run a set of heuristics to produce a good primal solution. This method is only called once per instance, meaning that the resulting computations can be shared across all approaches run on the particular instance.\n\nnote: Note\nImplementing this method is optional. If you don't need to do any prep work as all the requisite data is already available, simply defer to the available fallback method.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Justitia.build_model","page":"Interface","title":"Justitia.build_model","text":"build_model(\n    approach::AbstractApproach,\n    instance::AbstractInstance,\n    config::Dict{String,Any}=Dict{String,Any}()\n)::AbstractModel\n\nGiven a particular approach and a particular instance, build a model that encapsulates the two. The optional config argument contains parameters that are shared across all approaches and instances in a experiment run: for example, a time limit, a node limit, a constraint violation tolerance, etc.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Justitia.optimize!","page":"Interface","title":"Justitia.optimize!","text":"optimize!(model::AbstractModel)\n\nSolve the instance using the approach specified by model.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Justitia.tear_down","page":"Interface","title":"Justitia.tear_down","text":"tear_down(model::AbstractModel, T::Type{<:AbstractResult}))\n\nRecord the results of in individual experiment of a particular approach on a particular instance. The results will be stored in an object of type T.\n\nnote: Note\nThis function should only be called after optimize!(model) has been called.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Justitia.record_result!","page":"Interface","title":"Justitia.record_result!","text":"record_result!(table::AbstractResultTable, result::AbstractResult)\n\nGiven the results from an individual experiment, record it in table.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Entrypoint","page":"Interface","title":"Entrypoint","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"run_experiments!","category":"page"},{"location":"manual/interface/#Justitia.run_experiments!","page":"Interface","title":"Justitia.run_experiments!","text":"The entrypoint to run a set of experiments.\n\nfunction run_experiments!(\n    results_table::AbstractResultTable,\n    instances::Dict{String},\n    approaches::Dict{String},\n    result_type::Type{<:AbstractResult},\n    config::Dict{String,Any}=Dict(),\n)\n\nThis will consider every pair of AbstractInstance from keys(instances) with each AbstractApproach from keys(approaches), build the corresponding  AbstractModel, solve it, and record the resulting result of type result_type in record_table. The keys of the dicts instances and approaches are String names used to identify each in results_table.\n\n\n\n\n\n","category":"function"}]
}
